# -*- coding: utf-8 -*-
"""Image_to_Text_to_Sum_3_Conceptual_dataset_Gege.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UYvaZkTGDel7nLMC1HrXC5FsmYtBPfuc

## Installation & Loading Packages
"""

#@title install packages
!pip install transformers
!pip install transformers[sentencepiece]
!pip install -U sentence-transformers
!pip3 install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu116
!pip install gradio -q #interface
!pip install datasets
#!pip install transformers datasets accelerate nvidia-ml-py3

#@title Import Packages
import warnings
warnings.filterwarnings("ignore")
import torch.utils.data as data
import torchvision
from torchvision import transforms,datasets, models
from transformers import PegasusForConditionalGeneration, PegasusTokenizer,AutoTokenizer, AutoModel
from transformers import pipeline,TrainingArguments, Trainer, logging
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import torch
import requests
from PIL import Image, ImageFont, ImageDraw
from datasets import load_dataset
from datasets import Dataset
import cv2
import glob 
import os  
from os import listdir
import numpy as np
#from pynvml import *
from torchvision.io.image import decode_jpeg, read_file, ImageReadMode, write_jpeg, encode_jpeg, read_image,decode_image
from sentence_transformers import SentenceTransformer, util

#@title IMC installment
! pip install git+https://github.com/openai/CLIP.git

import os
from huggingface_hub import hf_hub_download
conceptual_weight = hf_hub_download(repo_id="akhaliq/CLIP-prefix-captioning-conceptual-weights", filename="conceptual_weights.pt")
coco_weight = hf_hub_download(repo_id="akhaliq/CLIP-prefix-captioning-COCO-weights", filename="coco_weights.pt")
import clip
import os
from torch import nn
import numpy as np
import torch
import torch.nn.functional as nnf
import sys
from typing import Tuple, List, Union, Optional
from transformers import GPT2Tokenizer, GPT2LMHeadModel, AdamW, get_linear_schedule_with_warmup
from tqdm import tqdm, trange
import skimage.io as io
import PIL.Image
import gradio as gr

N = type(None)
V = np.array
ARRAY = np.ndarray
ARRAYS = Union[Tuple[ARRAY, ...], List[ARRAY]]
VS = Union[Tuple[V, ...], List[V]]
VN = Union[V, N]
VNS = Union[VS, N]
T = torch.Tensor
TS = Union[Tuple[T, ...], List[T]]
TN = Optional[T]
TNS = Union[Tuple[TN, ...], List[TN]]
TSN = Optional[TS]
TA = Union[T, ARRAY]


D = torch.device
CPU = torch.device('cpu')


def get_device(device_id: int) -> D:
    if not torch.cuda.is_available():
        return CPU
    device_id = min(torch.cuda.device_count() - 1, device_id)
    return torch.device(f'cuda:{device_id}')


CUDA = get_device

class MLP(nn.Module):

    def forward(self, x: T) -> T:
        return self.model(x)

    def __init__(self, sizes: Tuple[int, ...], bias=True, act=nn.Tanh):
        super(MLP, self).__init__()
        layers = []
        for i in range(len(sizes) -1):
            layers.append(nn.Linear(sizes[i], sizes[i + 1], bias=bias))
            if i < len(sizes) - 2:
                layers.append(act())
        self.model = nn.Sequential(*layers)


class ClipCaptionModel(nn.Module):

    #@functools.lru_cache #FIXME
    def get_dummy_token(self, batch_size: int, device: D) -> T:
        return torch.zeros(batch_size, self.prefix_length, dtype=torch.int64, device=device)

    def forward(self, tokens: T, prefix: T, mask: Optional[T] = None, labels: Optional[T] = None):
        embedding_text = self.gpt.transformer.wte(tokens)
        prefix_projections = self.clip_project(prefix).view(-1, self.prefix_length, self.gpt_embedding_size)
        #print(embedding_text.size()) #torch.Size([5, 67, 768])
        #print(prefix_projections.size()) #torch.Size([5, 1, 768])
        embedding_cat = torch.cat((prefix_projections, embedding_text), dim=1)
        if labels is not None:
            dummy_token = self.get_dummy_token(tokens.shape[0], tokens.device)
            labels = torch.cat((dummy_token, tokens), dim=1)
        out = self.gpt(inputs_embeds=embedding_cat, labels=labels, attention_mask=mask)
        return out

    def __init__(self, prefix_length: int, prefix_size: int = 512):
        super(ClipCaptionModel, self).__init__()
        self.prefix_length = prefix_length
        self.gpt = GPT2LMHeadModel.from_pretrained('gpt2')
        self.gpt_embedding_size = self.gpt.transformer.wte.weight.shape[1]
        if prefix_length > 10:  # not enough memory
            self.clip_project = nn.Linear(prefix_size, self.gpt_embedding_size * prefix_length)
        else:
            self.clip_project = MLP((prefix_size, (self.gpt_embedding_size * prefix_length) // 2, self.gpt_embedding_size * prefix_length))


class ClipCaptionPrefix(ClipCaptionModel):

    def parameters(self, recurse: bool = True):
        return self.clip_project.parameters()

    def train(self, mode: bool = True):
        super(ClipCaptionPrefix, self).train(mode)
        self.gpt.eval()
        return self
        

#@title Caption Class Define

def generate_beam(model, tokenizer, beam_size: int = 5, prompt=None, embed=None,
                  entry_length=67, temperature=1., stop_token: str = '.'):

    model.eval()
    stop_token_index = tokenizer.encode(stop_token)[0]
    tokens = None
    scores = None
    device = next(model.parameters()).device
    seq_lengths = torch.ones(beam_size, device=device)
    is_stopped = torch.zeros(beam_size, device=device, dtype=torch.bool)
    with torch.no_grad():
        if embed is not None:
            generated = embed
        else:
            if tokens is None:
                tokens = torch.tensor(tokenizer.encode(prompt))
                tokens = tokens.unsqueeze(0).to(device)
                generated = model.gpt.transformer.wte(tokens)
        for i in range(entry_length):
            outputs = model.gpt(inputs_embeds=generated)
            logits = outputs.logits
            logits = logits[:, -1, :] / (temperature if temperature > 0 else 1.0)
            logits = logits.softmax(-1).log()
            if scores is None:
                scores, next_tokens = logits.topk(beam_size, -1)
                generated = generated.expand(beam_size, *generated.shape[1:])
                next_tokens, scores = next_tokens.permute(1, 0), scores.squeeze(0)
                if tokens is None:
                    tokens = next_tokens
                else:
                    tokens = tokens.expand(beam_size, *tokens.shape[1:])
                    tokens = torch.cat((tokens, next_tokens), dim=1)
            else:
                logits[is_stopped] = -float(np.inf)
                logits[is_stopped, 0] = 0
                scores_sum = scores[:, None] + logits
                seq_lengths[~is_stopped] += 1
                scores_sum_average = scores_sum / seq_lengths[:, None]
                scores_sum_average, next_tokens = scores_sum_average.view(-1).topk(beam_size, -1)
                next_tokens_source = next_tokens // scores_sum.shape[1]
                seq_lengths = seq_lengths[next_tokens_source]
                next_tokens = next_tokens % scores_sum.shape[1]
                next_tokens = next_tokens.unsqueeze(1)
                tokens = tokens[next_tokens_source]
                tokens = torch.cat((tokens, next_tokens), dim=1)
                generated = generated[next_tokens_source]
                scores = scores_sum_average * seq_lengths
                is_stopped = is_stopped[next_tokens_source]
            next_token_embed = model.gpt.transformer.wte(next_tokens.squeeze()).view(generated.shape[0], 1, -1)
            generated = torch.cat((generated, next_token_embed), dim=1)
            is_stopped = is_stopped + next_tokens.eq(stop_token_index).squeeze()
            if is_stopped.all():
                break
    scores = scores / seq_lengths
    output_list = tokens.cpu().numpy()
    output_texts = [tokenizer.decode(output[:int(length)]) for output, length in zip(output_list, seq_lengths)]
    order = scores.argsort(descending=True)
    output_texts = [output_texts[i] for i in order]
    return output_texts


def generate2(
        model,
        tokenizer,
        tokens=None,
        prompt=None,
        embed=None,
        entry_count=1,
        entry_length=67,  # maximum number of words
        top_p=0.8,
        temperature=1.,
        stop_token: str = '.',
):
    model.eval()
    generated_num = 0
    generated_list = []
    stop_token_index = tokenizer.encode(stop_token)[0]
    filter_value = -float("Inf")
    device = next(model.parameters()).device

    with torch.no_grad():

        for entry_idx in trange(entry_count):
            if embed is not None:
                generated = embed
            else:
                if tokens is None:
                    tokens = torch.tensor(tokenizer.encode(prompt))
                    tokens = tokens.unsqueeze(0).to(device)

                generated = model.gpt.transformer.wte(tokens)

            for i in range(entry_length):

                outputs = model.gpt(inputs_embeds=generated)
                logits = outputs.logits
                logits = logits[:, -1, :] / (temperature if temperature > 0 else 1.0)
                sorted_logits, sorted_indices = torch.sort(logits, descending=True)
                cumulative_probs = torch.cumsum(nnf.softmax(sorted_logits, dim=-1), dim=-1)
                sorted_indices_to_remove = cumulative_probs > top_p
                sorted_indices_to_remove[..., 1:] = sorted_indices_to_remove[
                                                    ..., :-1
                                                    ].clone()
                sorted_indices_to_remove[..., 0] = 0

                indices_to_remove = sorted_indices[sorted_indices_to_remove]
                logits[:, indices_to_remove] = filter_value
                next_token = torch.argmax(logits, -1).unsqueeze(0)
                next_token_embed = model.gpt.transformer.wte(next_token)
                if tokens is None:
                    tokens = next_token
                else:
                    tokens = torch.cat((tokens, next_token), dim=1)
                generated = torch.cat((generated, next_token_embed), dim=1)
                if stop_token_index == next_token.item():
                    break

            output_list = list(tokens.squeeze().cpu().numpy())
            output_text = tokenizer.decode(output_list)
            generated_list.append(output_text)

    return generated_list[0]

#@title Prediction function

is_gpu = False 
device = CUDA(0) if is_gpu else "cpu"
clip_model, preprocess = clip.load("ViT-B/32", device=device, jit=False)
tokenizer = GPT2Tokenizer.from_pretrained("gpt2")

def prediction(img):   # def prediction(img,model_name):   
  prefix_length = 10
    
  model = ClipCaptionModel(prefix_length)
  model_path = conceptual_weight
  model.load_state_dict(torch.load(model_path, map_location=CPU)) 
  model = model.eval() 
  device = CUDA(0) if is_gpu else "cpu"
  model = model.to(device)

  use_beam_search = False 
  #image = io.imread(img)
  image=cv2.imread(img)
  pil_image = PIL.Image.fromarray(image)  
  image = preprocess(pil_image).unsqueeze(0).to(device)
  with torch.no_grad():
      prefix = clip_model.encode_image(image).to(device, dtype=torch.float32)
      prefix_embed = model.clip_project(prefix).reshape(1, prefix_length, -1)
  if use_beam_search:
      generated_text_prefix = generate_beam(model, tokenizer, embed=prefix_embed)[0]
  else:
      generated_text_prefix = generate2(model, tokenizer, embed=prefix_embed)
  return generated_text_prefix

"""@article{mokady2021clipcap, title={ClipCap: CLIP Prefix for Image Captioning}, author={Mokady, Ron and Hertz, Amir and Bermano, Amit H}, journal={arXiv preprint arXiv:2111.09734}, year={2021} }
https://huggingface.co/spaces/akhaliq/CLIP_prefix_captioning/blob/main/app.py

# image set

load image
"""

import os
import cv2

from google.colab import drive
drive.mount('/content/drive')

cd '/content/drive/MyDrive/conceptual/AD'

dir= '/content/drive/MyDrive/conceptual/AD'

"""test image-caption"""

fileList=os.listdir(dir)
fileList[30]

image = io.imread('图片20.png')
pil_image = PIL.Image.fromarray(image) 
pil_image

txt=prediction(fileList[20])

txt

"""#Caption Set Generator"""

#Conceptual
def get_image_caption (path):
  
  fileList=os.listdir(path)
  #images =[cv2.imread(file) for file in fileList]
  n=len(fileList)
  text=[]
  for i in range(0,n):
    # image=transform(img)
    if fileList[i] is not None:
      print(i)
      pred=prediction(fileList[i])
      text.append(pred)
    else:
      error=str(os.path.basename(fileList[i]))
      print(error+' '+':'+'is None')
      continue

  return text

txt3=get_image_caption(dir)

txt3

def text_modifier(text):
  #加个similarity进去:好像没什么必要
  txt=" ".join(text)
  return txt

txt3_1=text_modifier(txt3)

txt3_1

txt3_2="the game is set to release."

txt3_3="the family on the beach."

"""## Summary Generators Test

pegasus-xsum
"""

txt4='Life is too short to spend time with people who suck the happiness out of you. If someone wants you in their life, they’ll make room for you. You shouldn’t have to fight for a spot. Never, ever insist yourself to someone who continuously overlooks your worth. And remember, it’s not the people that stand by your side when you’re at your best, but the ones who stand beside you when you’re at your worst that are your true friends.'

txt5='In the flood of darkness, hope is the light. It brings comfort, faith, and confidence. It gives us guidance when we are lost, and gives support when we are afraid. And the moment we give up hope, we give up our lives. The world we live in is disintegrating into a place of malice and hatred, where we need hope and find it harder. In this world of fear, hope to find better, but easier said than done, the more meaningful life of faith will make life meaningful.'

txt6="Only when you understand the true meaning of life can you live truly. Bittersweet as life is, it's still wonderful, and it's fascinating even in tragedy. If you're just alive, try harder and try to live wonderfully."

from transformers import PegasusForConditionalGeneration, PegasusTokenizer
# Load tokenizer 
tokenizer = PegasusTokenizer.from_pretrained("google/pegasus-xsum")
# Load model 
model_t = PegasusForConditionalGeneration.from_pretrained("google/pegasus-xsum")

tokens = tokenizer(txt3_2, truncation=True, padding="longest", return_tensors="pt")
summary = model_t.generate(**tokens)
tokenizer.decode(summary[0])

tokens = tokenizer(txt3_3, truncation=True, padding="longest", return_tensors="pt")
summary = model_t.generate(**tokens)
tokenizer.decode(summary[0])

tokens = tokenizer(txt4, truncation=True, padding="longest", return_tensors="pt")
summary = model_t.generate(**tokens)
tokenizer.decode(summary[0])

tokens = tokenizer(txt5, truncation=True, padding="longest", return_tensors="pt")
summary = model_t.generate(**tokens)
tokenizer.decode(summary[0])

"""bart-large-cnn"""

from transformers import pipeline

#google/pegasus-xsum  // pszemraj/led-base-book-summary
# philschmid/bart-large-cnn-samsum / facebook/bart-large-cnn / knkarthick/MEETING_SUMMARY(可)/google/pegasus-multi_news(extract & abstract)
#pszemraj/long-t5-tglobal-base-16384-book-summary（extract）/ sshleifer/distilbart-cnn-12-6 / 

summarizer = pipeline("summarization", model="facebook/bart-large-cnn")
print(summarizer(txt5, max_length=100, min_length=10, do_sample=False))

print(summarizer(txt3_1, max_length=100, min_length=10, do_sample=False))

"""bart-large-xsum"""

from transformers import pipeline

#google/pegasus-xsum  // pszemraj/led-base-book-summary
# philschmid/bart-large-cnn-samsum / facebook/bart-large-cnn / knkarthick/MEETING_SUMMARY(可)/google/pegasus-multi_news(extract & abstract)
#pszemraj/long-t5-tglobal-base-16384-book-summary（extract）/ sshleifer/distilbart-cnn-12-6 / 

summarizer2 = pipeline("summarization", model="facebook/bart-large-xsum")
print(summarizer2(txt5, max_length=100, min_length=7, do_sample=False))

print(summarizer2(txt3_1, max_length=100, min_length=7, do_sample=False))